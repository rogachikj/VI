"""
Предложете соодветна репрезентација на играта Pacman и напишете ги потребните функции во Python за да се реши следниот проблем за кој
една можна почетна состојба е прикажана на Слика 1:

"Во табла со димензии 10x10 се наоѓа човече. Човечето може да се придвижува на кое било соседно поле хоризонтално или вертикално,
доколку на соодветната позиција не постои пречка. Потребно е човечето да ги изеде сите точки поставени во таблата.
Во даден момент можни се четири акции на движење на човечето: продолжи право, продолжи назад, сврти лево и сврти десно.
На Слика 2 се прикажани можните движења на човечето за две насоки,
каде што со сина боја е обележана новата позиција добиена со акцијата продолжи право,
продолжи назад со црвена боја, сврти лево со сива боја и сврти десно со зелена боја.
Потребно е проблемот да се реши во најмал број на потези."

За сите тест примери изгледот и големината на таблата се исти како на примерот даден на Слика 1.
За сите тест примери позициите на пречките се исти. За секој тест пример почетната позиција на човечето се менува,
а исто така се менуваат и позиците на точките.

Од стандарден влез се читаат почетните x и y координати во кои на почетокот се наоѓа
човечето (ако таблата ја гледате во стандардниот координатен систем).
Следно се чита насоката кон која е поставен играчот ('istok', 'zapad', 'sever', 'jug').
Потоа се чита број на точки во таблата, по што во секој нов ред се читаат x и y координатите на точките во таблата
(ако таблата ја гледате во стандардниот координатен систем).

Движењата на човечето потребно е да ги именувате на следниот начин:

ProdolzhiPravo - за придвижување на човечето за едно поле нанапред
ProdolzhiNazad - за придвижување на човечето за едно поле наназад
SvrtiLevo - за придвижување на човечето за едно поле налево
SvrtiDesno - за придвижување на човечето за едно поле надесно
Вашиот код треба да има само еден повик на функција за приказ на стандарден излез (print) со кој ќе ја вратите секвенцата на движења која човечето треба да ја направи за да може од својата почетна позиција да стигне до позицијата на куќичката. Треба да примените информирано пребарување. Врз основа на тест примерите треба самите да определите кое пребарување ќе го користите. Дефинирајте прифатлива хевристичка функција за информираниот алгоритам.

Напомена: За различна хевристичка функција може да добиете различно оптимално решение кое не секогаш се поклопува со тест примерите.
"""

import bisect
from sys import maxsize as infinity

"""
Дефинирање на класа за структурата на проблемот кој ќе го решаваме со пребарување.
Класата Problem е апстрактна класа од која правиме наследување за дефинирање на основните 
карактеристики на секој проблем што сакаме да го решиме
"""


class Problem:
    def __init__(self, initial, goal=None):
        self.initial = initial
        self.goal = goal

    def successor(self, state):
        """За дадена состојба, врати речник од парови {акција : состојба}
        достапни од оваа состојба. Ако има многу следбеници, употребете
        итератор кој би ги генерирал следбениците еден по еден, наместо да
        ги генерирате сите одеднаш.
        :param state: дадена состојба
        :return:  речник од парови {акција : состојба} достапни од оваа
                  состојба
        :rtype: dict
        """
        raise NotImplementedError

    def actions(self, state):
        """За дадена состојба state, врати листа од сите акции што може да
        се применат над таа состојба
        :param state: дадена состојба
        :return: листа на акции
        :rtype: list
        """
        raise NotImplementedError

    def result(self, state, action):
        """За дадена состојба state и акција action, врати ја состојбата
        што се добива со примена на акцијата над состојбата
        :param state: дадена состојба
        :param action: дадена акција
        :return: резултантна состојба
        """
        raise NotImplementedError

    def goal_test(self, state):
        """Врати True ако state е целна состојба. Даденава имплементација
        на методот директно ја споредува state со self.goal, како што е
        специфицирана во конструкторот. Имплементирајте го овој метод ако
        проверката со една целна состојба self.goal не е доволна.
        :param state: дадена состојба
        :return: дали дадената состојба е целна состојба
        :rtype: bool
        """
        return state == self.goal

    def path_cost(self, c, state1, action, state2):
        """Врати ја цената на решавачкиот пат кој пристигнува во состојбата
        state2 од состојбата state1 преку акцијата action, претпоставувајќи
        дека цената на патот до состојбата state1 е c. Ако проблемот е таков
        што патот не е важен, оваа функција ќе ја разгледува само состојбата
        state2. Ако патот е важен, ќе ја разгледува цената c и можеби и
        state1 и action. Даденава имплементација му доделува цена 1 на секој
        чекор од патот.
        :param c: цена на патот до состојбата state1
        :param state1: дадена моментална состојба
        :param action: акција која треба да се изврши
        :param state2: состојба во која треба да се стигне
        :return: цена на патот по извршување на акцијата
        :rtype: float
        """
        return c + 1

    def value(self):
        """За проблеми на оптимизација, секоја состојба си има вредност.
        Hill-climbing и сличните алгоритми се обидуваат да ја максимизираат
        оваа вредност.
        :return: вредност на состојба
        :rtype: float
        """
        raise NotImplementedError


"""
Дефинирање на класата за структурата на јазел од пребарување.
Класата Node не се наследува
"""


class Node:
    def __init__(self, state, parent=None, action=None, path_cost=0):
        """Креирај јазол од пребарувачкото дрво, добиен од parent со примена
        на акцијата action
        :param state: моментална состојба (current state)
        :param parent: родителска состојба (parent state)
        :param action: акција (action)
        :param path_cost: цена на патот (path cost)
        """
        self.state = state
        self.parent = parent
        self.action = action
        self.path_cost = path_cost
        self.depth = 0  # search depth
        if parent:
            self.depth = parent.depth + 1

    def __repr__(self):
        return "<Node %s>" % (self.state,)

    def __lt__(self, node):
        return self.state < node.state

    def expand(self, problem):
        """Излистај ги јазлите достапни во еден чекор од овој јазол.
        :param problem: даден проблем
        :return: листа на достапни јазли во еден чекор
        :rtype: list(Node)
        """

        return [self.child_node(problem, action)
                for action in problem.actions(self.state)]

    def child_node(self, problem, action):
        """Дете јазел
        :param problem: даден проблем
        :param action: дадена акција
        :return: достапен јазел според дадената акција
        :rtype: Node
        """
        next_state = problem.result(self.state, action)
        return Node(next_state, self, action,
                    problem.path_cost(self.path_cost, self.state,
                                      action, next_state))

    def solution(self):
        """Врати ја секвенцата од акции за да се стигне од коренот до овој јазол.
        :return: секвенцата од акции
        :rtype: list
        """
        return [node.action for node in self.path()[1:]]

    def solve(self):
        """Врати ја секвенцата од состојби за да се стигне од коренот до овој јазол.
        :return: листа од состојби
        :rtype: list
        """
        return [node.state for node in self.path()[0:]]

    def path(self):
        """Врати ја листата од јазли што го формираат патот од коренот до овој јазол.
        :return: листа од јазли од патот
        :rtype: list(Node)
        """
        x, result = self, []
        while x:
            result.append(x)
            x = x.parent
        result.reverse()
        return result

    """Сакаме редицата од јазли кај breadth_first_search или 
    astar_search да не содржи состојби - дупликати, па јазлите што
    содржат иста состојба ги третираме како исти. [Проблем: ова може
    да не биде пожелно во други ситуации.]"""

    def __eq__(self, other):
        return isinstance(other, Node) and self.state == other.state

    def __hash__(self):
        return hash(self.state)


"""
Дефинирање на помошни структури за чување на листата на генерирани, но непроверени јазли
"""


class Queue:
    """Queue е апстрактна класа / интерфејс. Постојат 3 типа:
        Stack(): Last In First Out Queue (стек).
        FIFOQueue(): First In First Out Queue (редица).
        PriorityQueue(order, f): Queue во сортиран редослед (подразбирливо,од најмалиот кон
                                 најголемиот јазол).
    """

    def __init__(self):
        raise NotImplementedError

    def append(self, item):
        """Додади го елементот item во редицата
        :param item: даден елемент
        :return: None
        """
        raise NotImplementedError

    def extend(self, items):
        """Додади ги елементите items во редицата
        :param items: дадени елементи
        :return: None
        """
        raise NotImplementedError

    def pop(self):
        """Врати го првиот елемент од редицата
        :return: прв елемент
        """
        raise NotImplementedError

    def __len__(self):
        """Врати го бројот на елементи во редицата
        :return: број на елементи во редицата
        :rtype: int
        """
        raise NotImplementedError

    def __contains__(self, item):
        """Проверка дали редицата го содржи елементот item
        :param item: даден елемент
        :return: дали queue го содржи item
        :rtype: bool
        """
        raise NotImplementedError


class Stack(Queue):
    """Last-In-First-Out Queue."""

    def __init__(self):
        self.data = []

    def append(self, item):
        self.data.append(item)

    def extend(self, items):
        self.data.extend(items)

    def pop(self):
        return self.data.pop()

    def __len__(self):
        return len(self.data)

    def __contains__(self, item):
        return item in self.data


class FIFOQueue(Queue):
    """First-In-First-Out Queue."""

    def __init__(self):
        self.data = []

    def append(self, item):
        self.data.append(item)

    def extend(self, items):
        self.data.extend(items)

    def pop(self):
        return self.data.pop(0)

    def __len__(self):
        return len(self.data)

    def __contains__(self, item):
        return item in self.data


class PriorityQueue(Queue):
    """Редица во која прво се враќа минималниот (или максималниот) елемент
    (како што е определено со f и order). Оваа структура се користи кај
    информирано пребарување"""
    """"""

    def __init__(self, order=min, f=lambda x: x):
        """
        :param order: функција за подредување, ако order е min, се враќа елементот
                      со минимална f(x); ако order е max, тогаш се враќа елементот
                      со максимална f(x).
        :param f: функција f(x)
        """
        assert order in [min, max]
        self.data = []
        self.order = order
        self.f = f

    def append(self, item):
        bisect.insort_right(self.data, (self.f(item), item))

    def extend(self, items):
        for item in items:
            bisect.insort_right(self.data, (self.f(item), item))

    def pop(self):
        if self.order == min:
            return self.data.pop(0)[1]
        return self.data.pop()[1]

    def __len__(self):
        return len(self.data)

    def __contains__(self, item):
        return any(item == pair[1] for pair in self.data)

    def __getitem__(self, key):
        for _, item in self.data:
            if item == key:
                return item

    def __delitem__(self, key):
        for i, (value, item) in enumerate(self.data):
            if item == key:
                self.data.pop(i)


"""
Информирано пребарување во рамки на граф
"""


def memoize(fn, slot=None):
    """ Запамети ја пресметаната вредност за која била листа од
    аргументи. Ако е специфициран slot, зачувај го резултатот во
    тој slot на првиот аргумент. Ако slot е None, зачувај ги
    резултатите во речник.
    :param fn: зададена функција
    :type fn: function
    :param slot: име на атрибут во кој се чуваат резултатите од функцијата
    :type slot: str
    :return: функција со модификација за зачувување на резултатите
    :rtype: function
    """
    if slot:
        def memoized_fn(obj, *args):
            if hasattr(obj, slot):
                return getattr(obj, slot)
            else:
                val = fn(obj, *args)
                setattr(obj, slot, val)
                return val
    else:
        def memoized_fn(*args):
            if args not in memoized_fn.cache:
                memoized_fn.cache[args] = fn(*args)
            return memoized_fn.cache[args]

        memoized_fn.cache = {}
    return memoized_fn


def best_first_graph_search(problem, f):
    """Пребарувај низ следбениците на даден проблем за да најдеш цел. Користи
     функција за евалуација за да се одлучи кој е сосед најмногу ветува и
     потоа да се истражи. Ако до дадена состојба стигнат два пата, употреби
     го најдобриот пат.
    :param problem: даден проблем
    :type problem: Problem
    :param f: дадена функција за евалуација (проценка)
    :type f: function
    :return: Node or None
    :rtype: Node
    """
    f = memoize(f, 'f')
    node = Node(problem.initial)
    if problem.goal_test(node.state):
        return node
    frontier = PriorityQueue(min, f)
    frontier.append(node)
    explored = set()
    while frontier:
        node = frontier.pop()
        if problem.goal_test(node.state):
            return node
        explored.add(node.state)
        for child in node.expand(problem):
            if child.state not in explored and child not in frontier:
                frontier.append(child)
            elif child in frontier:
                incumbent = frontier[child]
                if f(child) < f(incumbent):
                    del frontier[incumbent]
                    frontier.append(child)
    return None


def greedy_best_first_graph_search(problem, h=None):
    """ Greedy best-first пребарување се остварува ако се специфицира дека f(n) = h(n).
    :param problem: даден проблем
    :type problem: Problem
    :param h: дадена функција за хевристика
    :type h: function
    :return: Node or None
    """
    h = memoize(h or problem.h, 'h')
    return best_first_graph_search(problem, h)


def astar_search(problem, h=None):
    """ A* пребарување е best-first graph пребарување каде f(n) = g(n) + h(n).
    :param problem: даден проблем
    :type problem: Problem
    :param h: дадена функција за хевристика
    :type h: function
    :return: Node or None
    """
    h = memoize(h or problem.h, 'h')
    return best_first_graph_search(problem, lambda n: n.path_cost + h(n))


def recursive_best_first_search(problem, h=None):
    """Recursive best first search - ја ограничува рекурзијата
    преку следење на f-вредноста на најдобриот алтернативен пат
    од било кој јазел предок (еден чекор гледање нанапред).
    :param problem: даден проблем
    :type problem: Problem
    :param h: дадена функција за хевристика
    :type h: function
    :return: Node or None
    """
    h = memoize(h or problem.h, 'h')

    def RBFS(problem, node, flimit):
        if problem.goal_test(node.state):
            return node, 0  # (втората вредност е неважна)
        successors = node.expand(problem)
        if len(successors) == 0:
            return None, infinity
        for s in successors:
            s.f = max(s.path_cost + h(s), node.f)
        while True:
            # Подреди ги според најниската f вредност
            successors.sort(key=lambda x: x.f)
            best = successors[0]
            if best.f > flimit:
                return None, best.f
            if len(successors) > 1:
                alternative = successors[1].f
            else:
                alternative = infinity
            result, best.f = RBFS(problem, best, min(flimit, alternative))
            if result is not None:
                return result, best.f

    node = Node(problem.initial)
    node.f = h(node)
    result, bestf = RBFS(problem, node, infinity)
    return result


# MOJOT KOD OD TUKA ↓↓↓

def move_forward(direction, y, x):
    if direction == 'istok':
        if y < 9 and [y + 1, x] not in obstacles_list:
            y += 1
        return direction, y, x

    if direction == 'zapad':
        if y > 0 and [y - 1, x] not in obstacles_list:
            y -= 1
        return direction, y, x

    if direction == 'sever':
        if x < 9 and [y, x + 1] not in obstacles_list:
            x += 1
        return direction, y, x

    if direction == 'jug':
        if x > 0 and [y, x - 1] not in obstacles_list:
            x -= 1
        return direction, y, x


def move_backwards(direction, y, x):
    if direction == 'zapad':
        if y < 9 and [y + 1, x] not in obstacles_list:
            y += 1
            direction = 'istok'
        return direction, y, x

    if direction == 'istok':
        if y > 0 and [y - 1, x] not in obstacles_list:
            y -= 1
            direction = 'zapad'
        return direction, y, x

    if direction == 'jug':
        if x < 9 and [y, x + 1] not in obstacles_list:
            x += 1
            direction = 'sever'
        return direction, y, x

    if direction == 'sever':
        if x > 0 and [y, x - 1] not in obstacles_list:
            x -= 1
            direction = 'jug'
        return direction, y, x


def move_left(direction, y, x):
    if direction == 'jug':
        if y < 9 and [y + 1, x] not in obstacles_list:
            y += 1
            direction = 'istok'
        return direction, y, x

    if direction == 'sever':
        if y > 0 and [y - 1, x] not in obstacles_list:
            y -= 1
            direction = 'zapad'
        return direction, y, x

    if direction == 'istok':
        if x < 9 and [y, x + 1] not in obstacles_list:
            x += 1
            direction = 'sever'
        return direction, y, x

    if direction == 'zapad':
        if x > 0 and [y, x - 1] not in obstacles_list:
            x -= 1
            direction = 'jug'
        return direction, y, x


def move_right(direction, y, x):
    if direction == 'sever':
        if y < 9 and [y + 1, x] not in obstacles_list:
            y += 1
            direction = 'istok'
        return direction, y, x

    if direction == 'jug':
        if y > 0 and [y - 1, x] not in obstacles_list:
            y -= 1
            direction = 'zapad'
        return direction, y, x

    if direction == 'zapad':
        if x < 9 and [y, x + 1] not in obstacles_list:
            x += 1
            direction = 'sever'
        return direction, y, x

    if direction == 'istok':
        if x > 0 and [y, x - 1] not in obstacles_list:
            x -= 1
            direction = 'jug'
        return direction, y, x


class Pacman(Problem):

    def __init__(self, obstacles, initial, goal=None):
        super().__init__(initial, goal)
        self.obstacles = obstacles

    def successor(self, state):
        succ = {}
        direction = state[0]
        pac_y = state[1]
        pac_x = state[2]
        dot_positions = state[3]

        new_direction, new_y, new_x = move_forward(direction, pac_y, pac_x)
        if new_x != pac_x or new_y != pac_y:
            succ['ProdolzhiPravo'] = (new_direction, new_y, new_x,
                                      tuple([s for s in dot_positions if s[0] != new_y or s[1] != new_x]))

        new_direction, new_y, new_x = move_backwards(direction, pac_y, pac_x)
        if new_x != pac_x or new_y != pac_y:
            succ['ProdolzhiNazad'] = (new_direction, new_y, new_x,
                                      tuple([s for s in dot_positions if s[0] != new_y or s[1] != new_x]))

        new_direction, new_y, new_x = move_left(direction, pac_y, pac_x)
        if new_x != pac_x or new_y != pac_y:
            succ['SvrtiLevo'] = (new_direction, new_y, new_x,
                                 tuple([s for s in dot_positions if s[0] != new_y or s[1] != new_x]))

        new_direction, new_y, new_x = move_right(direction, pac_y, pac_x)
        if new_x != pac_x or new_y != pac_y:
            succ['SvrtiDesno'] = (new_direction, new_y, new_x,
                                  tuple([s for s in dot_positions if s[0] != new_y or s[1] != new_x]))

        return succ

    def actions(self, state):
        return self.successor(state).keys()

    def result(self, state, action):
        return self.successor(state)[action]

    def goal_test(self, state):
        return len(state[-1]) == 0

    @staticmethod
    def mhd(pac_cor, dot_cor):
        return abs(pac_cor[0] - dot_cor[0]) + abs(pac_cor[1] - dot_cor[1])

    def h(self, node):
        sum = 0
        pac_y = node.state[1]
        pac_x = node.state[2]
        tmp_dict = dict()

        for y, x in node.state[3]:
            tmp = Pacman.mhd((pac_y, pac_x), (y, x))
            tmp_dict[y, x] = tmp

        tmp_dict = sorted(tmp_dict.items(), key=lambda kv: (kv[1], kv[0]))
        if len(tmp_dict) != 0:
            sum += tmp_dict[0][1]
        return sum


if __name__ == '__main__':
    obstacles_list = [[6, 9], [3, 9], [2, 9], [1, 9], [0, 9], [9, 8], [8, 8], [0, 8], [9, 7], [8, 7], [4, 7],
                      [5, 6], [4, 6], [3, 6], [0, 6], [4, 5], [9, 4], [8, 4], [1, 4], [1, 3], [6, 2], [1, 2], [8, 1],
                      [6, 1], [5, 1], [4, 1], [6, 0]]

    yy = int(input())
    xx = int(input())
    d = input()
    dot_num = int(input())
    dot_pos = ()
    for i in range(0, dot_num):
        tmp = input().split(",")
        dot_pos = dot_pos + ((int(tmp[0]), int(tmp[1])),)

    pacman = Pacman(obstacles_list, (d, yy, xx, dot_pos))
    result = astar_search(pacman)
    print(result.solution())
